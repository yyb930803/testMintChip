{"version":3,"file":"static/chunks/19a7f4cc.0ec1b63a08ed5c64.js","mappings":"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","sources":["webpack://_N_E/../node_modules/ical.js/build/ical.js","webpack://_N_E/<anon>"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */\n\n/* jshint ignore:start */\nvar ICAL;\n(function() {\n  /* istanbul ignore next */\n  if (typeof module === 'object') {\n    // CommonJS, where exports may be different each time.\n    ICAL = module.exports;\n  } else if (typeof HTMLScriptElement !== 'undefined' && 'noModule' in HTMLScriptElement.prototype) {\n    // Until we use ES6 exports, using <script type=\"module\"> we define ICAL on the window global.\n    window.ICAL = ICAL = {};\n  } else if (typeof ICAL !== 'object') {\n    ICAL = {};\n  }\n})();\n/* jshint ignore:end */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */\nICAL.foldLength = 75;\n\n\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */\nICAL.newLineChar = '\\r\\n';\n\n\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */\nICAL.helpers = {\n  /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */\n  updateTimezones: function(vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    }\n\n    //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    }\n\n    //create an object with one entry for each required tz\n    reqTzid = {};\n    for (i = 0; i < properties.length; i++) {\n      if ((tzid = properties[i].getParameter(\"tzid\"))) {\n        reqTzid[tzid] = true;\n      }\n    }\n\n    //delete any vtimezones that are not on the reqTzid list.\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    }\n\n    //create any missing, but registered timezones\n    for (i in reqTzid) {\n      if (\n        reqTzid.hasOwnProperty(i) &&\n        !vtimezones[i] &&\n        ICAL.TimezoneService.has(i)\n      ) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n\n    return vcal;\n  },\n\n  /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */\n  isStrictlyNaN: function(number) {\n    return typeof(number) === 'number' && isNaN(number);\n  },\n\n  /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */\n  strictParseInt: function(string) {\n    var result = parseInt(string, 10);\n\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error(\n        'Could not extract integer from \"' + string + '\"'\n      );\n    }\n\n    return result;\n  },\n\n  /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof(data) === 'undefined') {\n      return undefined;\n    }\n\n    if (data instanceof type) {\n      return data;\n    }\n    return new type(data);\n  },\n\n  /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */\n  unescapedIndexOf: function(buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */\n  binsearchInsert: function(list, seekVal, cmpfunc) {\n    if (!list.length)\n      return 0;\n\n    var low = 0, high = list.length - 1,\n        mid, cmpval;\n\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n\n      if (cmpval < 0)\n        high = mid - 1;\n      else if (cmpval > 0)\n        low = mid + 1;\n      else\n        break;\n    }\n\n    if (cmpval < 0)\n      return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0)\n      return mid + 1;\n    else\n      return mid;\n  },\n\n  /**\n   * Convenience function for debug output\n   * @private\n   */\n  dumpn: /* istanbul ignore next */ function() {\n    if (!ICAL.debug) {\n      return;\n    }\n\n    if (typeof (console) !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n\n  /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */\n  clone: function(aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n      return arr;\n    } else {\n      var obj = {};\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n      return obj;\n    }\n  },\n\n  /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\", pos = 0, line_length = 0;\n    //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n    while (line.length) {\n      var cp = line.codePointAt(pos);\n      if (cp < 128) ++line_length;\n      else if (cp < 2048) line_length += 2;//needs 2 UTF-8 bytes\n      else if (cp < 65536) line_length += 3;\n      else line_length += 4; //cp is less than 1114112\n      if (line_length < ICAL.foldLength + 1)\n        pos += cp > 65535 ? 2 : 1;\n      else {\n        result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n        line = line.substring(pos);\n        pos = line_length = 0;\n      }\n    }\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n\n  /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */\n  pad2: function pad(data) {\n    if (typeof(data) !== 'string') {\n      // handle fractions.\n      if (typeof(data) === 'number') {\n        data = parseInt(data);\n      }\n      data = String(data);\n    }\n\n    var len = data.length;\n\n    switch (len) {\n      case 0:\n        return '00';\n      case 1:\n        return '0' + data;\n      default:\n        return data;\n    }\n  },\n\n  /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */\n  trunc: function trunc(number) {\n    return (number < 0 ? Math.ceil(number) : Math.floor(number));\n  },\n\n  /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */\n  inherits: function(base, child, extra) {\n    function F() {}\n    F.prototype = base.prototype;\n    child.prototype = new F();\n\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n\n  /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */\n  extend: function(source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.design = (function() {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n\n      fromICAL: function(aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n\n      toICAL: function(aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape)\n          regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function(str) {\n          switch (str) {\n          case \"\\\\\":\n            return \"\\\\\\\\\";\n          case \";\":\n            return \"\\\\;\";\n          case \",\":\n            return \"\\\\,\";\n          case \"\\n\":\n            return \"\\\\n\";\n          /* istanbul ignore next */\n          default:\n            return str;\n          }\n        });\n      }\n    };\n    return result;\n  }\n\n  // default types used multiple times\n  var DEFAULT_TYPE_TEXT = { defaultType: \"text\" };\n  var DEFAULT_TYPE_TEXT_MULTI = { defaultType: \"text\", multiValue: \",\" };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: \"text\", structuredValue: \";\" };\n  var DEFAULT_TYPE_INTEGER = { defaultType: \"integer\" };\n  var DEFAULT_TYPE_DATETIME_DATE = { defaultType: \"date-time\", allowedTypes: [\"date-time\", \"date\"] };\n  var DEFAULT_TYPE_DATETIME = { defaultType: \"date-time\" };\n  var DEFAULT_TYPE_URI = { defaultType: \"uri\" };\n  var DEFAULT_TYPE_UTCOFFSET = { defaultType: \"utc-offset\" };\n  var DEFAULT_TYPE_RECUR = { defaultType: \"recur\" };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: \"date-and-or-time\", allowedTypes: [\"date-time\", \"date\", \"text\"] };\n\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n      case \"\\\\;\":\n        return \";\";\n      case \"\\\\,\":\n        return \",\";\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n      /* istanbul ignore next */\n      default:\n        return string;\n    }\n  }\n\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n    if (structuredEscape)\n      newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n\n      fromICAL: function(aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n          case 'FALSE':\n            return false;\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n\n      toICAL: function(aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n        return 'FALSE';\n      }\n\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n\n      fromICAL: function(aValue) {\n        var parsed = parseFloat(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function(aValue) {\n        var parsed = parseInt(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2) +\n                 aValue.substr(7, 2);\n        }\n      },\n\n      fromICAL: function(aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2) + ':' +\n                 aValue.substr(5, 2);\n        }\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n\n    // CN just wants a param-value\n    // \"CN\": { ... }\n\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\",\n               \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\",\n               \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\",\n               \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\",\n               \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n\n    uri: {\n      // TODO\n      /* ... */\n    },\n\n    \"binary\": {\n      decorate: function(aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n\n      undecorate: function(aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {\n      // needs to be an uri\n    },\n    \"date\": {\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      /**\n       * undecorates a time object.\n       */\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' +\n                 aValue.substr(4, 2) + '-' +\n                 aValue.substr(6, 2);\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n\n        if (len == 10) {\n          return aValue.substr(0, 4) +\n                 aValue.substr(5, 2) +\n                 aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n\n      }\n    },\n    \"date-time\": {\n      fromICAL: function(aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' +\n                       aValue.substr(4, 2) + '-' +\n                       aValue.substr(6, 2) + 'T' +\n                       aValue.substr(9, 2) + ':' +\n                       aValue.substr(11, 2) + ':' +\n                       aValue.substr(13, 2);\n\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) +\n                       aValue.substr(5, 2) +\n                       // grab the (DDTHH) segment\n                       aValue.substr(8, 5) +\n                       // MM\n                       aValue.substr(14, 2) +\n                       // SS\n                       aValue.substr(17, 2);\n\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function(aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n\n      fromICAL: function(string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n\n        return parts;\n      },\n\n      toICAL: function(parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n\n        return parts.join(\"/\");\n      },\n\n      decorate: function(aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function(string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n\n      toICAL: function(data) {\n        var str = \"\";\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n          var val = data[k];\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n        return str.substr(0, str.length - 1);\n      },\n\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n\n      undecorate: function(aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n\n    time: {\n      fromICAL: function(aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        }\n\n        // HH::MM::SSZ?\n        var result = aValue.substr(0, 2) + ':' +\n                     aValue.substr(2, 2) + ':' +\n                     aValue.substr(4, 2);\n\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      },\n\n      toICAL: function(aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n\n        var result = aValue.substr(0, 2) +\n                     aValue.substr(3, 2) +\n                     aValue.substr(6, 2);\n\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      }\n    }\n  });\n\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": { defaultType: \"uri\" },\n    \"attendee\": { defaultType: \"cal-address\" },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": { defaultType: \"duration\" },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": { defaultType: \"period\", multiValue: \",\" },\n    \"geo\": { defaultType: \"float\", structuredValue: \";\" },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": { defaultType: \"cal-address\" },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function(string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": { defaultType: \"duration\", allowedTypes: [\"duration\", \"date-time\"] },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  });\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n\n    date: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function(aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n\n    time: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n        var zone = splitzone[0], value = splitzone[1];\n\n        //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' +\n                  value.substr(2, 2) + ':' +\n                  value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n\n        return value + zone;\n      },\n\n      toICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n        var zone = splitzone[0], value = splitzone[1];\n\n        if (value.length == 8) {\n          value = value.substr(0, 2) +\n                  value.substr(3, 2) +\n                  value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n\n        return value + zone;\n      },\n\n      _splitZone: function(aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n\n        return [zone, value];\n      }\n    },\n\n    \"date-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n\n      toICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n\n    \"date-and-or-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') +\n               (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n\n      toICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) +\n               (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n    }\n  });\n\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\",\n               \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\",\n               \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": { defaultType: \"language-tag\" },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": { defaultType: \"text\", structuredValue: \";\" },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": { defaultType: \"timestamp\" },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": { defaultType: \"uri\", allowedTypes: [\"uri\", \"text\"] },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": { defaultType: \"text\", allowedTypes: [\"text\", \"utc-offset\", \"uri\"] },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {\n      // TODO\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      fromICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\",\n               \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n\n    adr: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    label: DEFAULT_TYPE_TEXT,\n\n    tel: { defaultType: \"phone-number\" },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n\n    tz: { defaultType: \"utc-offset\", allowedTypes: [\"utc-offset\", \"text\"] },\n    geo: { defaultType: \"float\", structuredValue: \";\" },\n\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    agent: { defaultType: \"vcard\", allowedTypes: [\"vcard\", \"text\", \"uri\"] },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n\n    class: DEFAULT_TYPE_TEXT,\n    key: { defaultType: \"binary\", allowedTypes: [\"binary\", \"text\"] }\n  });\n\n  /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n\n  /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n\n  /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n\n  /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */\n  var design = {\n    /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */\n\n    /**\n     * Can be set to false to make the parser more lenient.\n     */\n    strict: true,\n\n    /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */\n    defaultSet: icalSet,\n\n    /**\n     * The default type for unknown properties\n     * @type {String}\n     */\n    defaultType: 'unknown',\n\n    /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n\n\n    /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */\n    icalendar: icalSet,\n\n    /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard: vcardSet,\n\n    /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard3: vcard3Set,\n\n    /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */\n    getDesignSet: function(componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n\n  return design;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */\nICAL.stringify = (function() {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.component = function(component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n\n    var designSetName = component[0];\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (designSetName === 'vcard' && component[1].length > 0 &&\n            !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n    designSet = designSet || design.getDesignSet(designSetName);\n\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    }\n\n    // Ignore subcomponents if none exist, e.g. in vCard.\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n\n    result += 'END:' + name;\n    return result;\n  };\n\n  /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.property = function(property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n\n    var line = name;\n\n    var paramName;\n    for (paramName in params) {\n      var value = params[paramName];\n\n      /* istanbul ignore else */\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = (paramName in designSet.param) && designSet.param[paramName].multiValue;\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n\n\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n\n    var valueType = property[2];\n\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n\n      if (('structuredValue' in propDetails) && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    }\n\n    // push the VALUE property if type is not the default\n    // for the current property.\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n\n    line += ':';\n\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, multiValue, designSet, structuredValue\n      );\n    } else if (multiValue) {\n      line += stringify.multiValue(\n        property.slice(3), multiValue, valueType, null, designSet, false\n      );\n    } else if (structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, null, designSet, structuredValue\n      );\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n\n  /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */\n  stringify.propertyValue = function(value) {\n\n    if ((helpers.unescapedIndexOf(value, ',') === -1) &&\n        (helpers.unescapedIndexOf(value, ':') === -1) &&\n        (helpers.unescapedIndexOf(value, ';') === -1)) {\n\n      return value;\n    }\n\n    return '\"' + value + '\"';\n  };\n\n  /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */\n  stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n\n      if (i !== (len - 1)) {\n        result += delim;\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */\n  stringify.value = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */\n  stringify._rfc6868Unescape = function(val) {\n    return val.replace(/[\\n^\"]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { '\"': \"^'\", \"\\n\": \"^n\", \"^\": \"^^\" };\n\n  return stringify;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */\nICAL.parse = (function() {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n\n  ParserError.prototype = Error.prototype;\n\n  /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n\n    state.stack = [root];\n\n    parser._eachLine(input, function(err, line) {\n      parser._handleContentLine(line, state);\n    });\n\n\n    // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n    if (state.stack.length > 1) {\n      throw new ParserError(\n        'invalid ical body. component began but did not end'\n      );\n    }\n\n    state = null;\n\n    return (root.length == 1 ? root[0] : root);\n  }\n\n  /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */\n  parser.property = function(str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n    parser._handleContentLine(str, state);\n    return state.component[1][0];\n  };\n\n  /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */\n  parser.component = function(str) {\n    return parser(str);\n  };\n\n  // classes & constants\n  parser.ParserError = ParserError;\n\n  /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */\n\n\n  /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */\n  parser._handleContentLine = function(line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n\n    var lastParamIndex;\n    var lastValuePos;\n\n    // name of property or begin/end\n    var name;\n    var value;\n    // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n    var params = {};\n\n    /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n\n    if ((paramPos !== -1 && valuePos !== -1)) {\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n\n    var parsedParams;\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n      if ((lastValuePos =\n        line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n        state.stack.push(state.component);\n        state.component = newComponent;\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      }\n      // If it is not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n    } else {\n      /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */\n      throw new ParserError(\n        'invalid line (no token \";\" or \":\") \"' + line + '\"'\n      );\n    }\n\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    }\n\n    // attempt to determine value\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n\n    delete params.value;\n\n    /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */\n\n    var result;\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    }\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 &&\n            !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n    state.component[1].push(result);\n  };\n\n  /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */\n  parser._parseValue = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */\n  parser._parseParameters = function(line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value, valuePos = -1;\n    var type, multiValue, mvdelim;\n\n    // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while ((pos !== false) &&\n           (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n\n      var nextChar = line[pos + 1];\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n        if (multiValue && pos != -1) {\n            var extendedValue = true;\n            while (extendedValue) {\n              if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n                pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n              } else {\n                extendedValue = false;\n              }\n            }\n          }\n        if (pos === -1) {\n          throw new ParserError(\n            'invalid line (no matching double quote) \"' + line + '\"'\n          );\n        }\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1;\n\n        // move to next \";\"\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n\n      value = parser._rfc6868Escape(value);\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n\n      if (multiValue && (lcname in result)) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [\n            result[lcname],\n            value\n          ];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n    return [result, value, valuePos];\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */\n  parser._rfc6868Escape = function(val) {\n    return val.replace(/\\^['n^]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { \"^'\": '\"', \"^n\": \"\\n\", \"^^\": \"^\" };\n\n  /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */\n  parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n    if (delim.length === 0) {\n      return buffer;\n    }\n\n    // split each piece\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n      result.push(value);\n      lastPos = pos + delim.length;\n    }\n\n    // on the last piece take the rest of string\n    value = buffer.substr(lastPos);\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n    result.push(value);\n\n    return result.length == 1 ? result[0] : result;\n  };\n\n  /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */\n  parser._eachLine = function(buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n\n    var newlineOffset;\n\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n\n      firstChar = buffer[lastPos];\n\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(\n          lastPos + 1,\n          pos - lastPos - (newlineOffset + 1)\n        );\n      } else {\n        if (line)\n          callback(null, line);\n        // push line\n        line = buffer.substr(\n          lastPos,\n          pos - lastPos - newlineOffset\n        );\n      }\n\n      lastPos = pos;\n    } while (pos !== len);\n\n    // extra ending line\n    line = line.trim();\n\n    if (line.length)\n      callback(null, line);\n  };\n\n  return parser;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Component = (function() {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n\n  /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */\n  function Component(jCal, parent) {\n    if (typeof(jCal) === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    }\n\n    // mostly for legacy reasons.\n    this.jCal = jCal;\n\n    this.parent = parent || null;\n  }\n\n  Component.prototype = {\n    /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedPropertyCount: 0,\n\n    /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedComponentCount: 0,\n\n    /**\n     * The name of this component\n     * @readonly\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n\n    _hydrateComponent: function(index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (this._components[index]) {\n        return this._components[index];\n      }\n\n      var comp = new Component(\n        this.jCal[COMPONENT_INDEX][index],\n        this\n      );\n\n      this._hydratedComponentCount++;\n      return (this._components[index] = comp);\n    },\n\n    _hydrateProperty: function(index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n\n      var prop = new ICAL.Property(\n        this.jCal[PROPERTY_INDEX][index],\n        this\n      );\n\n      this._hydratedPropertyCount++;\n      return (this._properties[index] = prop);\n    },\n\n    /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */\n    getFirstSubcomponent: function(name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      }\n\n      // ensure we return a value (strict mode)\n      return null;\n    },\n\n    /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */\n    getAllSubcomponents: function(name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateComponent(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._components ||\n            (this._hydratedComponentCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n\n        return this._components || [];\n      }\n    },\n\n    /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */\n    hasProperty: function(name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n\n      var i = 0;\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */\n    getFirstProperty: function(name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */\n    getFirstPropertyValue: function(name) {\n      var prop = this.getFirstProperty(name);\n      if (prop) {\n        return prop.getFirstValue();\n      }\n\n      return null;\n    },\n\n    /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */\n    getAllProperties: function(name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateProperty(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._properties ||\n            (this._hydratedPropertyCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n\n        return this._properties || [];\n      }\n    },\n\n    _removeObjectByIndex: function(jCalIndex, cache, index) {\n      cache = cache || [];\n      // remove cached version\n      if (cache[index]) {\n        var obj = cache[index];\n        if (\"parent\" in obj) {\n            obj.parent = null;\n        }\n      }\n\n      cache.splice(index, 1);\n\n      // remove it from the jCal\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n\n    _removeObject: function(jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n\n      if (typeof(nameOrObject) === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    _removeAllObjects: function(jCalIndex, cache, name) {\n      var cached = this[cache];\n\n      // Unfortunately we have to run through all children to reset their\n      // parent property.\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1;\n\n      // descending search required because splice\n      // is used and will effect the indices.\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n\n    /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */\n    addSubcomponent: function(component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n\n    /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */\n    removeSubcomponent: function(nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */\n    removeAllSubcomponents: function(name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n\n    /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */\n    addProperty: function(property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n\n    /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    addPropertyWithValue: function(name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n\n      this.addProperty(prop);\n\n      return prop;\n    },\n\n    /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    updatePropertyWithValue: function(name, value) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n\n      return prop;\n    },\n\n    /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */\n    removeProperty: function(nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */\n    removeAllProperties: function(name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toString: function() {\n      return ICAL.stringify.component(\n        this.jCal, this._designSet\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */\n  Component.fromString = function(str) {\n    return new Component(ICAL.parse.component(str));\n  };\n\n  return Component;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Property = (function() {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n\n  var design = ICAL.design;\n\n  /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n\n    if (typeof(jCal) === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n    this._updateType();\n  }\n\n  Property.prototype = {\n\n    /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n\n    /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */\n    get parent() {\n      return this._parent;\n    },\n\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || (p && p._designSet != this._parent._designSet);\n\n      this._parent = p;\n\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n        this._updateType();\n      }\n\n      return p;\n    },\n\n    /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n\n    /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */\n    _updateType: function() {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = ('multiValue' in designSet.property[this.name]);\n          this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);\n        }\n      }\n    },\n\n    /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */\n    _hydrateValue: function(index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      }\n\n      // for the case where there is no value.\n      if (this.jCal.length <= (VALUE_INDEX + index)) {\n        return null;\n      }\n\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n        return (this._values[index] = this._decorate(\n          this.jCal[VALUE_INDEX + index]\n        ));\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n\n    /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */\n    _decorate: function(value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n\n    /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */\n    _undecorate: function(value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n\n    /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */\n    _setDecoratedValue: function(value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n\n    /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */\n    getParameter: function(name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */\n    getFirstParameter: function(name) {\n      var parameters = this.getParameter(name);\n\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n\n      return parameters;\n    },\n\n    /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */\n    setParameter: function(name, value) {\n      var lcname = name.toLowerCase();\n      if (typeof value === \"string\" &&\n          lcname in this._designSet.param &&\n          'multiValue' in this._designSet.param[lcname]) {\n          value = [value];\n      }\n      this.jCal[PROP_INDEX][name] = value;\n    },\n\n    /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */\n    removeParameter: function(name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n\n    /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */\n    getDefaultType: function() {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n      return design.defaultType;\n    },\n\n    /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */\n    resetType: function(type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n      this._updateType();\n    },\n\n    /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */\n    getFirstValue: function() {\n      return this._hydrateValue(0);\n    },\n\n    /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */\n    getValues: function() {\n      var len = this.jCal.length - VALUE_INDEX;\n\n      if (len < 1) {\n        // it is possible for a property to have no value.\n        return [];\n      }\n\n      var i = 0;\n      var result = [];\n\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n\n      return result;\n    },\n\n    /**\n     * Removes all values from this property\n     */\n    removeAllValues: function() {\n      if (this._values) {\n        this._values.length = 0;\n      }\n      this.jCal.length = 3;\n    },\n\n    /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */\n    setValues: function(values) {\n      if (!this.isMultiValue) {\n        throw new Error(\n          this.name + ': does not not support mulitValue.\\n' +\n          'override isMultiValue'\n        );\n      }\n\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n\n      if (len > 0 &&\n          typeof(values[0]) === 'object' &&\n          'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n\n    /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */\n    setValue: function(value) {\n      this.removeAllValues();\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.stringify.property(\n        this.jCal, this._designSet, true\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */\n  Property.fromString = function(str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n\n  return Property;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.UtcOffset = (function() {\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n\n  UtcOffset.prototype = {\n\n    /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */\n    hours: 0,\n\n    /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */\n    minutes: 0,\n\n    /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */\n    factor: 1,\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */\n    icaltype: \"utc-offset\",\n\n    /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */\n    clone: function() {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */\n    fromData: function(aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n      this._normalize();\n    },\n\n    /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */\n    fromSeconds: function(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n\n      secs -= (this.hours * 3600);\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n\n    /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */\n    toSeconds: function() {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n\n    /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n\n    _normalize: function() {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n      while (secs < -43200) { // = UTC-12:00\n        secs += 97200;\n      }\n      while (secs > 50400) { // = UTC+14:00\n        secs -= 97200;\n      }\n\n      this.fromSeconds(secs);\n\n      // Avoid changing the factor when on zero seconds\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") +\n              ICAL.helpers.pad2(this.hours) + ':' +\n              ICAL.helpers.pad2(this.minutes);\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */\n  UtcOffset.fromString = function(aString) {\n    // -05:00\n    var options = {};\n    //TODO: support seconds per rfc5545 ?\n    options.factor = (aString[0] === '+') ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n\n    return new ICAL.UtcOffset(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */\n  UtcOffset.fromSeconds = function(aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n\n  return UtcOffset;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Binary = (function() {\n\n  /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n\n  Binary.prototype = {\n    /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */\n    icaltype: \"binary\",\n\n    /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n\n    /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafał Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n\n      enc = tmp_arr.join('');\n\n      var r = data.length % 3;\n\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n\n    },\n\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        dec = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      data += '';\n\n      do { // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n\n      dec = tmp_arr.join('');\n\n      return dec;\n    },\n\n    /**\n     * The string representation of this value\n     * @return {String}\n     */\n    toString: function() {\n      return this.value;\n    }\n  };\n\n  /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */\n  Binary.fromString = function(aString) {\n    return new Binary(aString);\n  };\n\n  return Binary;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n      this.start = aData.start;\n    }\n\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n      this.end = aData.end;\n    }\n\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n      this.duration = aData.duration;\n    }\n  };\n\n  ICAL.Period.prototype = {\n\n    /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */\n    start: null,\n\n    /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */\n    end: null,\n\n    /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */\n    duration: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */\n    icalclass: \"icalperiod\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */\n    icaltype: \"period\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */\n    clone: function() {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n\n    /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n\n    /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */\n    getEnd: function() {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n\n    /**\n     * The string representation of this period.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n\n    /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n\n    /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.start.toICALString() + \"/\" +\n             (this.end || this.duration).toICALString();\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n\n    if (parts.length !== 2) {\n      throw new Error(\n        'Invalid string value: \"' + str + '\" must contain a \"/\" char.'\n      );\n    }\n\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n\n    var end = parts[1];\n\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n\n    return new ICAL.Period(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n\n  /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromJSON = function(aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Duration.prototype = {\n    /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */\n    weeks: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    days: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    hours: 0,\n\n    /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */\n    minutes: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */\n    seconds: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */\n    isNegative: false,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */\n    icalclass: \"icalduration\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */\n    icaltype: \"duration\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n\n    /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours +\n                    86400 * this.days + 7 * 86400 * this.weeks;\n      return (this.isNegative ? -seconds : seconds);\n    },\n\n    /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.isNegative = (aSeconds < 0);\n      this.days = ICAL.helpers.trunc(secs / 86400);\n\n      // If we have a flat number of weeks, use them.\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n\n      secs -= (this.days + 7 * this.weeks) * 86400;\n\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n\n      this.seconds = secs;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\",\n                         \"minutes\", \"seconds\", \"isNegative\"];\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n        var prop = propsToCopy[key];\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n\n    /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n\n    /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n\n    /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * The string representation of this duration.\n     * @return {String}\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n        return str;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.toString();\n    }\n  };\n\n  /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return (new ICAL.Duration()).fromSeconds(aSeconds);\n  };\n\n  /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */\n  function parseDurationChunk(letter, number, object) {\n    var type;\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        }\n        // period\n        break;\n      case 'D':\n        type = 'days';\n        break;\n      case 'W':\n        type = 'weeks';\n        break;\n      case 'H':\n        type = 'hours';\n        break;\n      case 'M':\n        type = 'minutes';\n        break;\n      case 'S':\n        type = 'seconds';\n        break;\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error(\n          'invalid duration value: Missing number before \"' + letter + '\"'\n        );\n      }\n      var num = parseInt(number, 10);\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error(\n          'invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"'\n        );\n      }\n      object[type] = num;\n    }\n\n    return 1;\n  }\n\n  /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */\n  ICAL.Duration.isValueString = function(string) {\n    return (string[0] === 'P' || string[1] === 'P');\n  };\n\n  /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error(\n        'invalid duration value: Not enough duration components in \"' + aStr + '\"'\n      );\n    }\n\n    return new ICAL.Duration(dict);\n  };\n\n  /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n\n\n(function() {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\",\n                 \"latitude\", \"longitude\"];\n\n  /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Timezone.prototype = {\n\n    /**\n     * Timezone identifier\n     * @type {String}\n     */\n    tzid: \"\",\n\n    /**\n     * Timezone location\n     * @type {String}\n     */\n    location: \"\",\n\n    /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */\n    tznames: \"\",\n\n    /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */\n    latitude: 0.0,\n\n    /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */\n    longitude: 0.0,\n\n    /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */\n    component: null,\n\n    /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */\n    expandedUntilYear: 0,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */\n    icalclass: \"icaltimezone\",\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        }\n\n        // Copy remaining passed properties\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      }\n\n      // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n\n      return this;\n    },\n\n    /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n\n      this._ensureCoverage(tt.year);\n\n      if (!this.changes.length) {\n        return 0;\n      }\n\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n\n      var change_num = this._findNearbyChange(tt_change);\n      var change_num_to_use = -1;\n      var step = 1;\n\n      // TODO: replace with bin search?\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                          change.prevUtcOffset);\n        }\n\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n\n        change_num += step;\n\n        if (change_num < 0) {\n          return 0;\n        }\n\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0,\n                                        tmp_change.prevUtcOffset);\n\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight &&\n              prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      }\n\n      // TODO return is_daylight?\n      return zone_change.utcOffset;\n    },\n\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(\n        this.changes,\n        change,\n        ICAL.Timezone._compare_change_fn\n      );\n\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n\n      return idx;\n    },\n\n    _ensureCoverage: function(aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n\n      var changesEndYear = aYear;\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(\n            subcomps[compIdx], changesEndYear, this.changes\n          );\n        }\n\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n\n    _expandComponent: function(aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") ||\n          !aComponent.hasProperty(\"tzoffsetto\") ||\n          !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = (aComponent.name == \"daylight\");\n        changebase.utcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue()\n        );\n\n        changebase.prevUtcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue()\n        );\n\n        return changebase;\n      }\n\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n\n        ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                        -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          }\n\n          changes.push(change);\n        }\n\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n\n          var iterator = rrule.iterator(dtstart);\n\n          var occ;\n          while ((occ = iterator.next())) {\n            change = init_changes();\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n\n            ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                            -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n\n      return changes;\n    },\n\n    /**\n     * The string representation of this timezone.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.tznames ? this.tznames : this.tzid);\n    }\n  };\n\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;\n    else if (a.year > b.year) return 1;\n\n    if (a.month < b.month) return -1;\n    else if (a.month > b.month) return 1;\n\n    if (a.day < b.day) return -1;\n    else if (a.day > b.day) return 1;\n\n    if (a.hour < b.hour) return -1;\n    else if (a.hour > b.hour) return 1;\n\n    if (a.minute < b.minute) return -1;\n    else if (a.minute > b.minute) return 1;\n\n    if (a.second < b.second) return -1;\n    else if (a.second > b.second) return 1;\n\n    return 0;\n  };\n\n  /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate ||\n        from_zone.tzid == to_zone.tzid ||\n        from_zone == ICAL.Timezone.localTimezone ||\n        to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, - utcOffset);\n\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n\n    return null;\n  };\n\n  /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n\n  /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n\n  /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n\n  /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(\n      change,\n      days,\n      hours,\n      minutes,\n      seconds,\n      change\n    );\n  };\n\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.TimezoneService = (function() {\n  var zones;\n\n  /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n\n    reset: function() {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n\n    /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */\n    has: function(tzid) {\n      return !!zones[tzid];\n    },\n\n    /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */\n    get: function(tzid) {\n      return zones[tzid];\n    },\n\n    /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */\n    register: function(name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n\n    /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */\n    remove: function(tzid) {\n      return (delete zones[tzid]);\n    }\n  };\n\n  // initialize defaults\n  TimezoneService.reset();\n\n  return TimezoneService;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n\n  /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    /* time defaults */\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n\n    this.fromData(data, zone);\n  };\n\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n\n  ICAL.Time.prototype = {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n\n    /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n\n    /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */\n    zone: null,\n\n    /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */\n    _pendingNormalization: false,\n\n    /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */\n    clone: function() {\n      return new ICAL.Time(this._time, this.zone);\n    },\n\n    /**\n     * Reset the time instance to epoch time\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n\n    /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */\n    resetTo: function icaltime_resetTo(year, month, day,\n                                       hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n\n    /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      if (aZone) {\n        this.zone = aZone;\n      }\n\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && (\"isDate\" in aData)) {\n        this.isDate = aData.isDate;\n      }\n\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(\n          aData.timezone\n        );\n\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      }\n\n      // Using Zeller's algorithm\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n\n      var h = (q + Y + ICAL.helpers.trunc(((m + 1) * 26) / 10) + ICAL.helpers.trunc(Y / 4));\n      /* istanbul ignore else */\n      if (true /* gregorian */) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {\n        h += 5;\n      }\n\n      // Normalize to 1 = wkst\n      h = ((h + 7 - firstDow) % 7) + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n\n    /**\n     * Calculate the day of year.\n     * @return {Number}\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = (ICAL.Time.isLeapYear(this.year) ? 1 : 0);\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= ((this.dayOfWeek() + 7 - firstDow) % 7);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n\n    /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */\n    getDominicalLetter: function() {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n\n    /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n\n      var start = 0;\n\n      var otherDay = this.clone();\n\n      if (pos >= 0) {\n        otherDay.day = 1;\n\n        // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        }\n\n        // set current start offset to current day.\n        start = otherDay.day;\n\n        // find the current day of week\n        var startDow = otherDay.dayOfWeek();\n\n        // calculate the difference between current\n        // day of the week and desired day of the week\n        var offset = aDayOfWeek - startDow;\n\n\n        // if the offset goes into the past\n        // week we add 7 so it goes into the next\n        // week. We only want to go forward in time here.\n        if (offset < 0)\n          // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7;\n\n        // add offset to start so start is the same\n        // day of the week as the desired day of week.\n        start += offset;\n\n        // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n        start -= aDayOfWeek;\n\n        // set week day\n        weekday = aDayOfWeek;\n      } else {\n\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth;\n\n        // find the ends weekday\n        var endDow = otherDay.dayOfWeek();\n\n        pos++;\n\n        weekday = (endDow - aDayOfWeek);\n\n        if (weekday < 0) {\n          weekday += 7;\n        }\n\n        weekday = daysInMonth - weekday;\n      }\n\n      weekday += pos * 7;\n\n      return start + weekday;\n    },\n\n    /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */\n    isNthWeekDay: function(aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      }\n\n      // get pos\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n\n      if (day === this.day) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      }\n      // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n      var week1;\n\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n\n      var daysBetween = (dt.subtractDate(week1).toSeconds() / 86400);\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n\n    /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = (aDuration.isNegative ? -1 : 1);\n\n      // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n\n    /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n\n      return rc;\n    },\n\n    /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = (this.zone.tzid == zone.tzid);\n\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n\n      copy.zone = zone;\n      return copy;\n    },\n\n    /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone ||\n          this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n\n    /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */\n    toICALString: function() {\n      var string = this.toString();\n\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n\n    /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var result = this.year + '-' +\n                   ICAL.helpers.pad2(this.month) + '-' +\n                   ICAL.helpers.pad2(this.day);\n\n      if (!this.isDate) {\n          result += 'T' + ICAL.helpers.pad2(this.hour) + ':' +\n                    ICAL.helpers.pad2(this.minute) + ':' +\n                    ICAL.helpers.pad2(this.second);\n\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day,\n                          this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n      this.adjust(0, 0, 0, 0);\n\n      return this;\n    },\n\n    /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours,\n                                     aExtraMinutes, aExtraSeconds, aTime) {\n\n      var minutesOverflow, hoursOverflow,\n          daysOverflow = 0, yearsOverflow = 0;\n\n      var second, minute, hour, day;\n      var daysInMonth;\n\n      var time = aTime || this._time;\n\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n\n        hour = time.hour + aExtraHours + hoursOverflow;\n\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      }\n\n\n      // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow;\n\n      // Now take care of the days (and adjust month if needed)\n      day = time.day + aExtraDays + daysOverflow;\n\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n          if (day <= daysInMonth) {\n            break;\n          }\n\n          time.month++;\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n\n      time.day = day;\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n      var offset = this.utcOffset();\n\n      // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n      var ms = Date.UTC(\n        this.year,\n        this.month - 1,\n        this.day,\n        this.hour,\n        this.minute,\n        this.second - offset\n      );\n\n      // seconds\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n\n    /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */\n    toJSON: function() {\n      var copy = [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'isDate'\n      ];\n\n      var result = Object.create(null);\n\n      var i = 0;\n      var len = copy.length;\n      var prop;\n\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n\n      return result;\n    }\n\n  };\n\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n            this._pendingNormalization = false;\n          }\n\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n\n          return val;\n        }\n      });\n\n    }\n\n    /* istanbul ignore else */\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n\n  /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n\n    if (month < 1 || month > 12) return days;\n\n    days = _daysInMonth[month];\n\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n\n    return days;\n  };\n\n  /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return ((year % 4) == 0);\n    } else {\n      return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));\n    }\n  };\n\n  /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n\n    if (doy < 1) {\n      year--;\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n\n    tt.year = year;\n    tt.isDate = true;\n\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n\n    tt.auto_normalize = true;\n    return tt;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromDateString = function(aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromDateTimeString = function(aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error(\n        'invalid date-time value: \"' + aValue + '\"'\n      );\n    }\n\n    var zone;\n\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    }\n\n    // 2012-10-10T10:10:10(Z)?\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n\n    return time;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is “floating” - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n\n  /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n\n    t.day -= dow - wkst;\n\n    return t;\n  };\n\n  /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */\n  ICAL.Time.getDominicalLetter = function(yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n\n  /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n\n  /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */\n  ICAL.Time.daysInYearPassedMonth = [\n    [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],\n    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\n  ];\n\n  /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n\n  /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n\n\n(function() {\n\n  /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */\n  ICAL.VCardTime = function(data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n\n    this.icaltype = icaltype || \"date-and-or-time\";\n\n    this.fromData(data, zone);\n  };\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */\n    icalclass: \"vcardtime\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */\n    icaltype: \"date-and-or-time\",\n\n    /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */\n    zone: null,\n\n    /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */\n    clone: function() {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n\n    _normalize: function() {\n      return this;\n    },\n\n    /**\n     * @inheritdoc\n     */\n    utcOffset: function() {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n\n    /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */\n    toICALString: function() {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year, m = this.month, d = this.day;\n      var h = this.hour, mm = this.minute, s = this.second;\n\n      var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\n      var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\n\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : (hasMonth || hasDay ? '--' : '')) +\n                     (hasMonth ? p2(m) : '') +\n                     (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') +\n                     (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') +\n                     (hasMinute && hasSecond ? ':' : '') +\n                     (hasSecond ? p2(s) : '');\n\n      var zone;\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n        case \"date\":\n          return datepart;\n      }\n      return null;\n    }\n  });\n\n  /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */\n  ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n    var parts = aValue.split('T');\n    var dt = parts[0], tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0], tm = splitzone[1];\n\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n\n  var REVERSE_DOW_MAP = {};\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\",\n                    \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\",\n                    \"BYMONTH\", \"BYSETPOS\"];\n\n  /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n\n    if (data && typeof(data) === 'object') {\n      this.fromData(data);\n    }\n  };\n\n  ICAL.Recur.prototype = {\n    /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */\n    parts: null,\n\n    /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */\n    interval: 1,\n\n    /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */\n    wkst: ICAL.Time.MONDAY,\n\n    /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */\n    until: null,\n\n    /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */\n    count: null,\n\n    /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */\n    freq: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */\n    icalclass: \"icalrecur\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */\n    icaltype: \"recur\",\n\n    /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */\n    iterator: function(aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n\n    /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n\n    /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n\n    /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n\n    /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n\n    /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n\n    /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return (ucname in this.parts ? this.parts[ucname].slice() : []);\n    },\n\n    /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n\n      return next;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */\n    fromData: function(data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n\n    /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var res = Object.create(null);\n      res.freq = this.freq;\n\n      if (this.count) {\n        res.count = this.count;\n      }\n\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n        var kparts = this.parts[k];\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return res;\n    },\n\n    /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return str;\n    }\n  };\n\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n\n    result = ICAL.helpers.strictParseInt(result);\n\n    if (min !== undefined && value < min) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be > ' + min\n      );\n    }\n\n    if (max !== undefined && value > max) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be < ' + min\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return ((DOW_MAP[string] - firstDow + 7) % 7) + 1;\n  };\n\n  /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = (num + firstDow - ICAL.Time.SUNDAY);\n    if (dow > 7) {\n      dow -= 7;\n    }\n    return REVERSE_DOW_MAP[dow];\n  };\n\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n\n  /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY',\n                      'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n\n  var optionDesign = {\n    FREQ: function(value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error(\n          'invalid frequency \"' + value + '\" expected: \"' +\n          ALLOWED_FREQ.join(', ') + '\"'\n        );\n      }\n    },\n\n    COUNT: function(value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n\n    INTERVAL: function(value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n\n    UNTIL: function(value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n\n    WKST: function(value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function(value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */\n  ICAL.Recur.fromString = function(string) {\n    var data = ICAL.Recur._stringToData(string, false);\n    return new ICAL.Recur(data);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */\n  ICAL.Recur.fromData = function(aData) {\n    return new ICAL.Recur(aData);\n  };\n\n  /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */\n  ICAL.Recur._stringToData = function(string, fmtIcal) {\n    var dict = Object.create(null);\n\n    // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n    var values = string.split(';');\n    var len = values.length;\n\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = (fmtIcal ? lcname : ucname);\n      var value = parts[1];\n\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n        dict[name] = (partArr.length == 1 ? partArr[0] : partArr);\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurIterator = (function() {\n\n  /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n\n  icalrecur_iterator.prototype = {\n\n    /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */\n    completed: false,\n\n    /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */\n    rule: null,\n\n    /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */\n    occurrence_number: 0,\n\n    /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */\n    by_indices: null,\n\n    /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */\n    initialized: false,\n\n    /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */\n    by_data: null,\n\n    /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */\n    days: null,\n\n    /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */\n    days_index: 0,\n\n    /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */\n    fromData: function(options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n\n      if (options.occurrence_number)\n        this.occurrence_number = options.occurrence_number;\n\n      this.days = options.days || [];\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n\n      this.by_indices = options.by_indices;\n\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n\n      this.initialized = options.initialized || false;\n\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n\n    /**\n     * Intialize the iterator\n     * @private\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      }\n\n      // If the BYYEARDAY appares, no other date rule part may appear\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts ||\n            \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      }\n\n      // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      }\n\n      // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n      if (this.rule.freq == \"MONTHLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      }\n\n      // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n      if (this.rule.freq == \"WEEKLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      }\n\n      // BYYEARDAY may only appear in YEARLY rules\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n          if ((this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0) || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n          if (this.days.length > 0) {\n            break;\n          }\n          this.increment_year(this.rule.interval);\n        }\n\n        this._nextByYearDay();\n      }\n\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        // Check every weekday in BYDAY with relative dow and pos.\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos);\n\n          // If |pos| >= 6, the byday is invalid for a monthly rule.\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          }\n\n          // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n\n          this.last.day = dayOfMonth;\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n        this.last = tempLast.clone();\n\n        //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n\n    },\n\n    /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */\n    next: function icalrecur_iterator_next() {\n      var before = (this.last ? this.last.clone() : null);\n\n      if ((this.rule.count && this.occurrence_number >= this.rule.count) ||\n          (this.rule.until && this.last.compare(this.rule.until) > 0)) {\n\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n\n        return null;\n      }\n\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n\n\n      var valid;\n      do {\n        valid = 1;\n\n        switch (this.rule.freq) {\n        case \"SECONDLY\":\n          this.next_second();\n          break;\n        case \"MINUTELY\":\n          this.next_minute();\n          break;\n        case \"HOURLY\":\n          this.next_hour();\n          break;\n        case \"DAILY\":\n          this.next_day();\n          break;\n        case \"WEEKLY\":\n          this.next_week();\n          break;\n        case \"MONTHLY\":\n          valid = this.next_month();\n          break;\n        case \"YEARLY\":\n          this.next_year();\n          break;\n\n        default:\n          return null;\n        }\n      } while (!this.check_contracting_rules() ||\n               this.last.compare(this.dtstart) < 0 ||\n               !valid);\n\n      // TODO is this valid?\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" +\n                        \"you from death by recursion\");\n      }\n\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\",\n                               \"minute\", \"hour\", \"next_second\");\n    },\n\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\",\n                               \"monthday\", \"next_minute\");\n    },\n\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = (this.rule.freq == \"DAILY\");\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n\n      return 0;\n    },\n\n    next_week: function next_week() {\n      var end_of_data = 0;\n\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        }\n\n        // HACK should be first month of the year\n        this.last.month = 1;\n        this.last.day = 1;\n\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n\n        this.last.day += 7 * week_no;\n\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n\n      return end_of_data;\n    },\n\n    /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */\n    normalizeByMonthDayRules: function(year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year);\n\n      // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n      var newRules = [];\n\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx];\n\n        // if this rule falls outside of given\n        // month discard it.\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        }\n\n        // negative case\n        if (rule < 0) {\n          // we add (not subtract it is a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero: it is invalid.\n          continue;\n        }\n\n        // only add unique items...\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n\n      }\n\n      // unique and sort\n      return newRules.sort(function(a, b) { return a - b; });\n    },\n\n    /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */\n    _byDayAndMonthDay: function(isInit) {\n      var byMonthDay; // setup in initMonth\n      var byDay = this.by_data.BYDAY;\n\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n      var dayLen = byDay.length;\n\n      // we are not valid by default\n      var dataIsValid = 0;\n\n      var daysInMonth;\n      var self = this;\n      // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n      var lastDay = this.last.day;\n\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(\n          self.last.month, self.last.year\n        );\n\n        byMonthDay = self.normalizeByMonthDayRules(\n          self.last.year,\n          self.last.month,\n          self.by_data.BYMONTHDAY\n        );\n\n        dateLen = byMonthDay.length;\n\n        // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n        while (byMonthDay[dateIdx] <= lastDay &&\n               !(isInit && byMonthDay[dateIdx] == lastDay) &&\n               dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n\n      initMonth();\n\n      // should come after initMonth\n      if (isInit) {\n        lastDay -= 1;\n      }\n\n      // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n      var monthsCounter = 48;\n\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--;\n        // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n        date = lastDay + 1;\n\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        }\n\n        // find next date\n        var next = byMonthDay[dateIdx++];\n\n        // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        }\n\n        // Now we can loop through the day rules to see\n        // if one matches the current month date.\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n\n          this.last.day = lastDay;\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        }\n\n        // It is completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n\n\n      return dataIsValid;\n    },\n\n    next_month: function next_month() {\n      var this_freq = (this.rule.freq == \"MONTHLY\");\n      var data_valid = 1;\n\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n          this.last.day = last_day;\n        }\n\n        data_valid = 0;\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") ||\n                this.check_set_position(++setpos) ||\n                this.check_set_position(setpos - setpos_total - 1)) {\n\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n\n      return data_valid;\n    },\n\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n\n        dow -= this.rule.wkst;\n\n        if (dow < 0) {\n          dow += 7;\n        }\n\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow,\n                                                  this.last.year);\n\n        /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n\n        return end_of_data;\n      }\n    },\n\n    next_year: function next_year() {\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n\n      this._nextByYearDay();\n\n      return 1;\n    },\n\n    _nextByYearDay: function _nextByYearDay() {\n        var doy = this.days[this.days_index];\n        var year = this.last.year;\n        if (doy < 1) {\n            // Time.fromDayOfYear(doy, year) indexes relative to the\n            // start of the given year. That is different from the\n            // semantics of BYYEARDAY where negative indexes are an\n            // offset from the end of the given year.\n            doy += 1;\n            year += 1;\n        }\n        var next = ICAL.Time.fromDayOfYear(doy, year);\n        this.last.day = next.day;\n        this.last.month = next.month;\n    },\n\n    /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr,\n                                        aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = (this.rule.freq == aInterval);\n      var end_of_data = 0;\n\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n\n      return end_of_data;\n    },\n\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n\n    increment_month: function increment_month() {\n      this.last.day = 1;\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n\n    increment_generic: function increment_generic(inc, aDateAttr,\n                                                  aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n\n    has_by_data: function has_by_data(aRuleType) {\n      return (aRuleType in this.rule.parts);\n    },\n\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = [];\n\n      // We need our own copy with a few keys set\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n\n      var partCount = Object.keys(parts).length;\n\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 2 &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) ||\n                  this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n\n              var first_matching_day = ((dow + 7 - first_dow) % 7) + 1;\n              var last_matching_day = daysInMonth - ((last_dow + 7 - dow) % 7);\n\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        }\n        // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n        this.days.sort(function(a, b) { return a - b; }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 &&\n              this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n      return 0;\n    },\n\n    expand_by_day: function expand_by_day(aYear) {\n\n      var days_list = [];\n      var tmp = this.last.clone();\n\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n\n      var start_dow = tmp.dayOfWeek();\n\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n\n        if (pos == 0) {\n          var tmp_start_doy = ((dow + 7 - start_dow) % 7) + 1;\n\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n\n        } else if (pos > 0) {\n          var first;\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n      return days_list;\n    },\n\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n\n        if ((pos == 0 && dow == this_dow) ||\n            (tt.nthWeekDay(dow, pos) == tt.day)) {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n\n    /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos);\n        // negative numbers are not false-y\n        return idx !== -1;\n      }\n      return false;\n    },\n\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n\n      if (aRuleType in this.by_data &&\n          ruleMapValue == icalrecur_iterator.CONTRACT) {\n\n        var ruleType = this.by_data[aRuleType];\n\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n      return pass;\n    },\n\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n\n      return (this.check_contract_restriction(\"BYSECOND\", this.last.second) &&\n              this.check_contract_restriction(\"BYMINUTE\", this.last.minute) &&\n              this.check_contract_restriction(\"BYHOUR\", this.last.hour) &&\n              this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) &&\n              this.check_contract_restriction(\"BYWEEKNO\", weekNo) &&\n              this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) &&\n              this.check_contract_restriction(\"BYMONTH\", this.last.month) &&\n              this.check_contract_restriction(\"BYYEARDAY\", doy));\n    },\n\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n      return deftime;\n    },\n\n    /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var result = Object.create(null);\n\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n\n      return result;\n    }\n  };\n\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n\n  return icalrecur_iterator;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurExpansion = (function() {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') ||\n           comp.hasProperty('rrule') ||\n           comp.hasProperty('recurrence-id');\n  }\n\n  /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n\n  RecurExpansion.prototype = {\n    /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */\n    complete: false,\n\n    /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */\n    ruleIterators: null,\n\n    /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    ruleDates: null,\n\n    /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    exDates: null,\n\n    /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */\n    ruleDateInc: 0,\n\n    /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */\n    exDateInc: 0,\n\n    /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    exDate: null,\n\n    /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    ruleDate: null,\n\n    /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */\n    fromData: function(options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n\n        this.ruleIterators = options.ruleIterators.map(function(item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n\n        if (typeof(options.complete) !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */\n    next: function() {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n\n      var maxTries = 500;\n      var currentTry = 0;\n\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error(\n            'max tries have occured, rule may be impossible to forfill.'\n          );\n        }\n\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last);\n\n        // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        }\n\n        // no next rule day or recurrence rule is first.\n        if (!next || (iter && next.compare(iter.last) > 0)) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone();\n          // move to next so we can continue\n          iter.next();\n        }\n\n        // if the ruleDate is still next increment it.\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n\n        this.last = next;\n\n        // check the negative rules\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n\n          if (compare < 0) {\n            this._nextExDay();\n          }\n\n          // if the current rule is excluded skip it.\n          if (compare === 0) {\n            this._nextExDay();\n            continue;\n          }\n        }\n\n        //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n        return this.last;\n      }\n    },\n\n    /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */\n    toJSON: function() {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n\n      return result;\n    },\n\n    /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */\n    _extractDates: function(component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(\n          result,\n          prop,\n          compareTime\n        );\n\n        // ordered insert\n        result.splice(idx, 0, prop);\n      }\n\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n\n      var idx;\n\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n\n      return result;\n    },\n\n    /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */\n    _init: function(component) {\n      this.ruleIterators = [];\n\n      this.last = this.dtstart.clone();\n\n      // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate');\n\n        // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n        if ((this.ruleDates[0]) &&\n            (this.ruleDates[0].compare(this.dtstart) < 0)) {\n\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(\n            this.ruleDates,\n            this.last,\n            compareTime\n          );\n        }\n\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n\n        var rule;\n        var iter;\n\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter);\n\n          // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n          iter.next();\n        }\n      }\n\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate');\n        // if we have a .last day we increment the index to beyond it.\n        this.exDateInc = ICAL.helpers.binsearchInsert(\n          this.exDates,\n          this.last,\n          compareTime\n        );\n\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n\n    /**\n     * Advance to the next exdate\n     * @private\n     */\n    _nextExDay: function() {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n\n    /**\n     * Advance to the next rule date\n     * @private\n     */\n    _nextRuleDay: function() {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n\n    /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */\n    _nextRecurrenceIter: function() {\n      var iters = this.ruleIterators;\n\n      if (iters.length === 0) {\n        return null;\n      }\n\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter;\n\n      // loop through each iterator\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last;\n\n        // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n        if (iter.completed) {\n          len--;\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n          iters.splice(iterIdx, 1);\n          continue;\n        }\n\n        // find the most recent possible choice\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      }\n\n      // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n      return chosenIter;\n    }\n  };\n\n  return RecurExpansion;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Event = (function() {\n\n  /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function(event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n\n  Event.prototype = {\n\n    THISANDFUTURE: 'THISANDFUTURE',\n\n    /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */\n    exceptions: null,\n\n    /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */\n    strictExceptions: false,\n\n    /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */\n    relateException: function(obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n\n      var id = obj.recurrenceId.toString();\n\n      // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n      this.exceptions[id] = obj;\n\n      // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n      if (obj.modifiesFuture()) {\n        var item = [\n          obj.recurrenceId.toUnixTime(), id\n        ];\n\n        // we keep them sorted so we can find the nearest\n        // value later on...\n        var idx = ICAL.helpers.binsearchInsert(\n          this.rangeExceptions,\n          item,\n          compareRangeException\n        );\n\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n\n    /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */\n    modifiesFuture: function() {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n\n    /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */\n    findRangeException: function(time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(\n        this.rangeExceptions,\n        [utc],\n        compareRangeException\n      );\n\n      idx -= 1;\n\n      // occurs before\n      if (idx < 0) {\n        return null;\n      }\n\n      var rangeItem = this.rangeExceptions[idx];\n\n      /* istanbul ignore next: sanity check only */\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n\n      return rangeItem[1];\n    },\n\n    /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */\n\n    /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */\n    getOccurrenceDetails: function(occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(\n          occurrence\n        );\n        var end;\n\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId];\n\n          // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n          result.item = exception;\n\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone();\n\n            // zones must be same otherwise subtract may be incorrect.\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n\n          end = start.clone();\n          end.addDuration(exception.duration);\n\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */\n    iterator: function(startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n\n    /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */\n    isRecurring: function() {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n\n    /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */\n    isRecurrenceException: function() {\n      return this.component.hasProperty('recurrence-id');\n    },\n\n    /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */\n    getRecurrenceTypes: function() {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n\n      return result;\n    },\n\n    /**\n     * The uid of this event\n     * @type {String}\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n\n    /**\n     * The start date\n     * @type {ICAL.Time}\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n\n    /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n      if (!endDate) {\n          var duration = this._firstProp('duration');\n          endDate = this.startDate.clone();\n          if (duration) {\n              endDate.addDuration(duration);\n          } else if (endDate.isDate) {\n              endDate.day += 1;\n          }\n      }\n      return endDate;\n    },\n\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n      this._setTime('dtend', value);\n    },\n\n    /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n      return duration;\n    },\n\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n\n      this._setProp('duration', value);\n    },\n\n    /**\n     * The location of the event.\n     * @type {String}\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n\n    set location(value) {\n      return this._setProp('location', value);\n    },\n\n    /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n\n\n    /**\n     * The event summary\n     * @type {String}\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n\n    /**\n     * The event description.\n     * @type {String}\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n\n    set description(value) {\n      this._setProp('description', value);\n    },\n\n    /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */\n    get color() {\n      return this._firstProp('color');\n    },\n\n    set color(value) {\n      this._setProp('color', value);\n    },\n\n    /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n\n    /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n\n    /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n\n    /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */\n    _setTime: function(propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      }\n\n      // utc and local don't get a tzid\n      if (\n        time.zone === ICAL.Timezone.localTimezone ||\n        time.zone === ICAL.Timezone.utcTimezone\n      ) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n\n      prop.setValue(time);\n    },\n\n    _setProp: function(name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n\n    _firstProp: function(name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n\n    /**\n     * The string representation of this event.\n     * @return {String}\n     */\n    toString: function() {\n      return this.component.toString();\n    }\n\n  };\n\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n\n  return Event;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.ComponentParser = (function() {\n  /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */\n  function ComponentParser(options) {\n    if (typeof(options) === 'undefined') {\n      options = {};\n    }\n\n    var key;\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  ComponentParser.prototype = {\n\n    /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */\n    parseEvent: true,\n\n    /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */\n    parseTimezone: true,\n\n\n    /* SAX like events here for reference */\n\n    /**\n     * Fired when parsing is complete\n     * @callback\n     */\n    oncomplete: /* istanbul ignore next */ function() {},\n\n    /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */\n    onerror: /* istanbul ignore next */ function(err) {},\n\n    /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */\n    ontimezone: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */\n    onevent: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */\n    process: function(ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof(ical) === 'string') {\n        ical = ICAL.parse(ical);\n      }\n\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n\n      for (; i < len; i++) {\n        component = components[i];\n\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n            break;\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n            break;\n          default:\n            continue;\n        }\n      }\n\n      //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n      this.oncomplete();\n    }\n  };\n\n  return ComponentParser;\n}());\n"],"names":["ICAL","DURATION_LETTERS","OPTIONS","zones","TimezoneService","module","exports","foldLength","newLineChar","helpers","updateTimezones","vcal","allsubs","properties","vtimezones","reqTzid","i","tzid","name","getAllSubcomponents","length","getFirstProperty","getFirstValue","concat","getAllProperties","getParameter","hasOwnProperty","removeSubcomponent","has","addSubcomponent","get","component","isStrictlyNaN","number","isNaN","strictParseInt","string","result","parseInt","formatClassType","data","type","unescapedIndexOf","buffer","search","pos","indexOf","binsearchInsert","list","seekVal","cmpfunc","mid","cmpval","low","high","Math","floor","dumpn","debug","console","input","log","dump","arguments","clone","aSrc","aDeep","Date","getTime","Array","isArray","arr","push","obj","Object","prototype","call","foldline","aLine","line","line_length","cp","codePointAt","substring","substr","pad2","String","trunc","ceil","inherits","base","child","extra","F","extend","source","target","key","descr","getOwnPropertyDescriptor","defineProperty","design","FROM_VCARD_NEWLINE","TO_VCARD_NEWLINE","createTextType","fromNewline","toNewline","matches","fromICAL","aValue","structuredEscape","newline","value","replace","replaceNewlineReplace","toICAL","regEx","str","DEFAULT_TYPE_TEXT","defaultType","DEFAULT_TYPE_TEXT_MULTI","multiValue","DEFAULT_TYPE_TEXT_STRUCTURED","structuredValue","DEFAULT_TYPE_INTEGER","DEFAULT_TYPE_DATETIME_DATE","allowedTypes","DEFAULT_TYPE_DATETIME","DEFAULT_TYPE_URI","DEFAULT_TYPE_UTCOFFSET","DEFAULT_TYPE_RECUR","DEFAULT_TYPE_DATE_ANDOR_TIME","commonProperties","commonValues","values","float","parsed","parseFloat","integer","decorate","UtcOffset","fromString","undecorate","toString","icalValues","text","uri","aString","Binary","aBinary","aProp","strict","Time","fromDateString","len","date","fromDateTimeString","duration","Duration","period","parts","split","isValueString","join","Period","fromJSON","toJSON","recur","Recur","_stringToData","k","val","numericDayToIcalDay","toUpperCase","fromData","aRecur","time","icalProperties","detectType","vcardValues","VCardTime","fromDateAndOrTimeString","splitzone","_splitZone","zone","isFromIcal","lastChar","signChar","sign","timestamp","vcardProperties","vcard3Values","binary","vcard","vcard3Properties","fn","n","nickname","photo","bday","adr","label","tel","email","mailer","tz","geo","title","role","logo","agent","org","note","prodid","rev","sound","class","icalSet","param","allowXName","allowIanaToken","valueType","multiValueSeparateDQuote","property","vcardSet","vcard3Set","defaultSet","components","vcard3","vevent","vtodo","vjournal","valarm","vtimezone","daylight","standard","icalendar","getDesignSet","componentName","isInDesign","stringify","DEFAULT_VALUE_TYPE","jCal","designSet","props","propIdx","propLen","designSetName","comps","compIdx","compLen","noFold","paramName","propDetails","jsName","params","map","_rfc6868Unescape","propertyValue","isDefault","slice","delim","innerMulti","x","RFC6868_REPLACE_MAP","parse","CHAR","ParserError","message","e","stack","shift","parser","state","root","_eachLine","err","_handleContentLine","Error","lastParamIndex","lastValuePos","parsedParams","propertyDetails","valuePos","paramPos","toLowerCase","_parseParameters","newComponent","pop","_parseMultiValue","_parseValue","start","mvdelim","lcname","lastParam","_rfc6868Escape","nextChar","extendedValue","nextPos","propValuePos","delimiter","lastPos","callback","firstChar","newlineOffset","trim","Component","parent","_hydratedPropertyCount","_hydratedComponentCount","_designSet","parentDesign","_hydrateComponent","index","_components","comp","_hydrateProperty","_properties","prop","Property","getFirstSubcomponent","jCalLen","hasProperty","getFirstPropertyValue","_removeObjectByIndex","jCalIndex","cache","splice","_removeObject","nameOrObject","objects","cached","_removeAllObjects","idx","nameOrComp","removed","removeAllSubcomponents","addProperty","removeProperty","addPropertyWithValue","setValue","updatePropertyWithValue","nameOrProp","removeAllProperties","_parent","getDefaultType","_updateType","p","designSetChanged","isDecorated","isMultiValue","isStructuredValue","_hydrateValue","_values","VALUE_INDEX","_decorate","_undecorate","_setDecoratedValue","getFirstParameter","parameters","setParameter","removeParameter","details","resetType","removeAllValues","getValues","setValues","icaltype","toICALString","aData","hours","minutes","factor","fromSeconds","toSeconds","_normalize","aSeconds","secs","abs","compare","other","a","b","options","instance","decodeValue","_b64_decode","setEncodedValue","_b64_encode","h1","h2","h3","h4","bits","b64","ac","enc","tmp_arr","o1","charCodeAt","o2","charAt","r","o3","fromCharCode","wrappedJSObject","end","icalclass","getDuration","subtractDate","getEnd","addDuration","aLenient","fromDateOrDateTimeString","weeks","days","seconds","isNegative","propsToCopy","reset","aOther","thisSeconds","otherSeconds","normalize","aStr","dict","create","chunks","numeric","parseDurationChunk","letter","object","num","Timezone","location","tznames","latitude","longitude","expandedUntilYear","changes","utcOffset","tt","utcTimezone","localTimezone","_ensureCoverage","year","tt_change","month","day","hour","minute","second","change_num","_findNearbyChange","change_num_to_use","step","change","prevUtcOffset","adjust_change","cmp","_compare_change_fn","zone_change","utcOffset_change","tmp_change","prev_zone_change","is_daylight","aYear","_minimumExpansionYear","today","now","changesEndYear","EXTRA_COVERAGE","MAX_YEAR","subcomps","_expandComponent","sort","aComponent","dtstart","convert_tzoffset","offset","init_changes","changebase","rdatekey","rdate","isDate","rrule","until","adjust","occ","iterator","next","convert_time","from_zone","to_zone","count","keys","utc","Z","UTC","GMT","register","timezone","remove","_time","_dowCache","_wnCache","_cachedUnixTime","_pendingNormalization","epochTime","resetTo","fromJSDate","aDate","useUTC","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","aZone","dayOfWeek","aWeekStart","firstDow","SUNDAY","dowCacheKey","q","m","Y","h","dayOfYear","is_leap","isLeapYear","diypm","daysInYearPassedMonth","startOfWeek","endOfWeek","startOfMonth","endOfMonth","daysInMonth","startOfYear","endOfYear","startDoyWeek","aFirstDayOfWeek","delta","getDominicalLetter","nthWeekDay","aDayOfWeek","aPos","weekday","otherDay","endDow","isNthWeekDay","dow","weekNumber","week1","wnCacheKey","dt","isoyear","weekOneStarts","daysBetween","answer","aDuration","mult","unixTime","toUnixTime","subtractDateTz","compareDateOnlyTz","attr","_cmp_attr","convertToZone","rc","copy","zone_equals","toJSDate","aExtraDays","aExtraHours","aExtraMinutes","aExtraSeconds","aTime","minutesOverflow","hoursOverflow","daysOverflow","yearsOverflow","fromUnixTime","epoch","ms","defineAttr","set","_daysInMonth","fromDayOfYear","aDayOfYear","doy","auto_normalize","fromStringv2","aProperty","t","wkst","DEFAULT_WEEK_START","THURSDAY","yr","LTRS","dom","MONDAY","TUESDAY","WEDNESDAY","FRIDAY","SATURDAY","apply","p2","y","d","mm","s","hasMonth","hasDay","hasHour","hasMinute","hasSecond","datepart","hasYear","timepart","aIcalType","part","v","tmz","tm","dtlen","tmlen","hasDashDate","hasDashTime","o","DOW_MAP","SU","MO","TU","WE","TH","FR","SA","REVERSE_DOW_MAP","parseNumericValue","min","max","undefined","interval","freq","aStart","RecurIterator","rule","isFinite","isByCount","addComponent","aType","ucname","setComponent","aValues","getComponent","getNextOccurrence","aStartTime","aRecurrenceId","iter","uckey","partDesign","optionDesign","INTERVAL","icalDayToNumericDay","res","kparts","VALID_DAY_NAMES","VALID_BYDAY_PART","ALLOWED_FREQ","FREQ","fmtIcal","COUNT","UNTIL","WKST","test","BYSECOND","bind","BYMINUTE","BYHOUR","BYDAY","BYMONTHDAY","BYYEARDAY","BYWEEKNO","BYMONTH","BYSETPOS","partArr","partArrIdx","partArrLen","icalrecur_iterator","completed","last","occurrence_number","by_indices","initialized","by_data","days_index","init","sort_byday_rules","setup_defaults","bydayParts","ruleDayOfWeek","wkdy","dayName","expand_year_days","increment_year","_nextByYearDay","has_by_data","tempLast","initLast","dayOfMonth","increment_month","_byDayAndMonthDay","valid","before","next_second","next_minute","next_hour","next_day","next_week","next_month","next_year","check_contracting_rules","next_generic","increment_second","inc","increment_generic","increment_minute","increment_hour","this_freq","increment_monthday","end_of_data","next_weekday_by_week","week_no","normalizeByMonthDayRules","rules","newRules","ruleIdx","isInit","byMonthDay","dateLen","byDay","dateIdx","dayLen","dataIsValid","self","lastDay","initMonth","nextMonth","monthsCounter","dayIdx","data_valid","setpos","setpos_total","last_day","is_day_in_byday","check_set_position","coded_day","match","aRuleType","aInterval","aDateAttr","aFollowingAttr","aPreviousIncr","has_by_rule","dta","years","aFactor","aNextIncrement","nextunit","validWeeks","monthIdx","first_week","last_week","weekIdx","weekno","partCount","t1","monthkey","t2","monthdaykey","t3","day_","month_","expand_by_day","first_dow","doy_offset","last_dow","by_month_day","spIndex","daycodedkey","month_day","first_matching_day","last_matching_day","expandedDays","daykey","days_list","tmp","start_dow","end_dow","end_year_day","first","tmp_start_doy","this_dow","aRules","j","one","check_contract_restriction","indexMapValue","_indexMap","ruleMapValue","_expandMap","pass","CONTRACT","ruleType","bydatakey","weekNo","req","deftime","UNKNOWN","EXPAND","ILLEGAL","RecurExpansion","formatTime","item","compareTime","ruleDates","exDates","complete","ruleIterators","ruleDateInc","exDateInc","exDate","ruleDate","_init","currentTry","_nextRecurrenceIter","_nextRuleDay","_nextExDay","_extractDates","propertyName","handleProp","forEach","iterTime","chosenIter","iters","iterIdx","Event","_rangeExceptionCache","exceptions","rangeExceptions","strictExceptions","relateException","isRecurrenceException","event","compareRangeException","THISANDFUTURE","uid","id","recurrenceId","modifiesFuture","range","findRangeException","rangeItem","getOccurrenceDetails","occurrence","utcId","startDate","endDate","rangeExceptionId","exception","startDiff","original","newStart","startTime","isRecurring","getRecurrenceTypes","_firstProp","_setProp","_setTime","attendees","summary","description","color","organizer","sequence","propName","ComponentParser","parseEvent","parseTimezone","oncomplete","onerror","ontimezone","onevent","process","ical"],"sourceRoot":""}